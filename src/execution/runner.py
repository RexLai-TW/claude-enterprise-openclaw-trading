"""
Strategy Execution Runner

Deterministically executes strategy trees against live or recent market data.
Outputs trading signals (buy/sell/hold) with amounts and reasoning.
Does NOT execute actual trades - AI never touches your money.
"""

import asyncio
import logging
from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass, field
from enum import Enum
import pandas as pd
import json
from opentelemetry import trace

from ..strategy.tree_schema import StrategyTree, StrategyNode, Action, Condition
from ..strategy.tree_schema import ActionType, ConditionType, IndicatorType, PositionSizingMethod
from ..data.market_data import MarketDataInterface, create_market_data_connector
from .circuit_breaker import CircuitBreaker, CircuitBreakerConfig

class SignalType(str, Enum):
    """Types of trading signals"""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    REBALANCE = "rebalance"
    STOP_LOSS = "stop_loss"
    TAKE_PROFIT = "take_profit"

@dataclass
class TradingSignal:
    """
    A trading signal generated by strategy execution
    """
    signal_type: SignalType
    symbol: str
    amount: float  # Dollar amount or percentage based on sizing_method
    sizing_method: PositionSizingMethod
    price: Optional[float] = None  # Current market price when signal generated
    confidence: float = 1.0  # Signal confidence (0-1)
    reasoning: str = ""  # Human-readable explanation
    
    # Strategy context
    strategy_id: str = ""
    node_id: str = ""
    timestamp: datetime = field(default_factory=datetime.now)
    
    # Risk parameters
    stop_loss_price: Optional[float] = None
    take_profit_price: Optional[float] = None
    max_position_size: Optional[float] = None
    
    # Execution metadata
    urgency: str = "normal"  # "low", "normal", "high"
    validity_period: int = 3600  # Signal valid for N seconds
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary for serialization"""
        return {
            'signal_type': self.signal_type.value,
            'symbol': self.symbol,
            'amount': self.amount,
            'sizing_method': self.sizing_method.value,
            'price': self.price,
            'confidence': self.confidence,
            'reasoning': self.reasoning,
            'strategy_id': self.strategy_id,
            'node_id': self.node_id,
            'timestamp': self.timestamp.isoformat(),
            'stop_loss_price': self.stop_loss_price,
            'take_profit_price': self.take_profit_price,
            'max_position_size': self.max_position_size,
            'urgency': self.urgency,
            'validity_period': self.validity_period,
        }
    
    def to_json(self, indent: int = 2) -> str:
        """Convert signal to JSON string"""
        return json.dumps(self.to_dict(), indent=indent, default=str)
    
    def is_valid(self) -> bool:
        """Check if signal is still valid based on timestamp and validity period"""
        elapsed = (datetime.now() - self.timestamp).total_seconds()
        return elapsed <= self.validity_period

@dataclass
class ExecutionConfig:
    """Configuration for strategy execution"""
    # Data source configuration
    data_source: str = "yfinance"
    timeframe: str = "1d"
    lookback_periods: int = 100  # Historical periods to fetch for indicators
    
    # Execution settings
    dry_run: bool = True  # Always True - we never execute real trades
    signal_cooldown_minutes: int = 15  # Minimum time between signals for same symbol
    max_signals_per_day: int = 50  # Maximum signals per day
    
    # Risk management
    circuit_breaker_enabled: bool = True
    max_position_size_pct: float = 10.0  # Max 10% of portfolio per position
    max_portfolio_exposure_pct: float = 80.0  # Max 80% of portfolio exposed
    
    # Market data settings
    real_time_data: bool = False  # Use real-time data vs last close
    market_hours_only: bool = True  # Only generate signals during market hours
    
    # Signal output
    output_format: str = "json"  # "json", "csv", "console"
    save_signals: bool = True  # Save signals to file
    signal_retention_days: int = 30  # Days to retain signal history

@dataclass
class PortfolioPosition:
    """Current portfolio position for a symbol"""
    symbol: str
    quantity: float
    avg_price: float
    current_price: float
    market_value: float
    unrealized_pnl: float
    unrealized_pnl_pct: float
    last_updated: datetime

@dataclass
class PortfolioState:
    """Current portfolio state"""
    total_value: float
    cash: float
    positions: Dict[str, PortfolioPosition] = field(default_factory=dict)
    total_exposure_pct: float = 0.0
    last_updated: datetime = field(default_factory=datetime.now)
    
    def get_position_value(self, symbol: str) -> float:
        """Get current market value of position"""
        if symbol in self.positions:
            return self.positions[symbol].market_value
        return 0.0
    
    def update_position_price(self, symbol: str, new_price: float) -> None:
        """Update position with new market price"""
        if symbol in self.positions:
            position = self.positions[symbol]
            position.current_price = new_price
            position.market_value = position.quantity * new_price
            position.unrealized_pnl = position.market_value - (position.quantity * position.avg_price)
            position.unrealized_pnl_pct = position.unrealized_pnl / (position.quantity * position.avg_price)
            position.last_updated = datetime.now()

class ExecutionRunner:
    """
    Strategy execution engine that runs strategy trees against live market data
    and generates trading signals. Does NOT execute actual trades.
    
    Key Features:
    - Deterministic strategy tree evaluation
    - Real-time or end-of-day signal generation  
    - Circuit breaker safety controls
    - Comprehensive signal reasoning and metadata
    - Portfolio-aware position sizing
    """
    
    def __init__(self, config: ExecutionConfig):
        self.config = config
        self.logger = logging.getLogger('claude_trading.execution')
        self.tracer = trace.get_tracer(__name__)
        
        # Initialize data connector
        data_config = {'rate_limit': 2000, 'demo_mode': True}
        self.data_connector = create_market_data_connector(
            config.data_source, data_config
        )
        
        # Initialize circuit breaker
        if config.circuit_breaker_enabled:
            cb_config = CircuitBreakerConfig(
                max_drawdown_pct=0.15,  # 15% max drawdown
                max_position_size_pct=config.max_position_size_pct,
                max_daily_trades=config.max_signals_per_day
            )
            self.circuit_breaker = CircuitBreaker(cb_config)
        else:
            self.circuit_breaker = None
        
        # Portfolio state (simulated - for position sizing calculations)
        self.portfolio_state = PortfolioState(
            total_value=100000.0,  # Assume $100k portfolio for sizing
            cash=100000.0
        )
        
        # Signal tracking
        self.signal_history: List[TradingSignal] = []
        self.last_signal_time: Dict[str, datetime] = {}  # symbol -> last signal time
        self.daily_signal_count = 0
        self.last_signal_date = datetime.now().date()
        
        # Technical indicator cache
        self.indicator_cache: Dict[str, Dict[str, pd.Series]] = {}
        self.cache_last_updated: Dict[str, datetime] = {}
    
    async def execute_strategy(self, strategy: StrategyTree, portfolio_value: Optional[float] = None) -> List[TradingSignal]:
        """
        Execute strategy tree and generate trading signals
        """
        with self.tracer.start_as_current_span("execute_strategy") as span:
            span.set_attribute("strategy_id", strategy.id)
            span.set_attribute("strategy_name", strategy.name)
            
            self.logger.info(f"Executing strategy: {strategy.name} (ID: {strategy.id})")
            
            # Update portfolio value if provided
            if portfolio_value:
                self.portfolio_state.total_value = portfolio_value
            
            # Reset daily counter if new day
            today = datetime.now().date()
            if today != self.last_signal_date:
                self.daily_signal_count = 0
                self.last_signal_date = today
            
            # Check circuit breaker
            if self.circuit_breaker and not self.circuit_breaker.is_safe_to_trade():
                self.logger.warning("Circuit breaker active - no signals generated")
                return []
            
            # Check market hours if required
            if self.config.market_hours_only and not self._is_market_hours():
                self.logger.info("Outside market hours - no signals generated")
                return []
            
            # Get current market data
            symbols = strategy.get_symbols()
            current_data = await self._fetch_current_market_data(symbols)
            
            if not current_data:
                self.logger.warning("No market data available - no signals generated")
                return []
            
            # Calculate technical indicators
            await self._update_indicators(symbols, current_data)
            
            # Evaluate strategy tree
            signals = await self._evaluate_strategy_tree(strategy, current_data)
            
            # Apply safety filters
            filtered_signals = self._apply_safety_filters(signals)
            
            # Update signal history
            self.signal_history.extend(filtered_signals)
            
            # Update circuit breaker with new signals
            if self.circuit_breaker:
                for signal in filtered_signals:
                    self.circuit_breaker.record_signal(signal)
            
            span.set_attribute("signals_generated", len(filtered_signals))
            
            self.logger.info(f"Generated {len(filtered_signals)} trading signals")
            
            # Log signals for debugging
            for signal in filtered_signals:
                self.logger.info(f"SIGNAL: {signal.signal_type.value.upper()} {signal.symbol} "
                              f"${signal.amount:.2f} - {signal.reasoning}")
            
            return filtered_signals
    
    async def _fetch_current_market_data(self, symbols: List[str]) -> Dict[str, Dict[str, Any]]:
        """Fetch current market data for symbols"""
        current_data = {}
        
        for symbol in symbols:
            try:
                # Fetch recent data (last 1-2 days to get current price)
                data = await self.data_connector.get_market_data(symbol, "5d", self.config.timeframe)
                
                if data['data']:
                    # Get most recent data point
                    latest = data['data'][-1]
                    current_data[symbol] = {
                        'price': latest['close'],
                        'volume': latest['volume'],
                        'timestamp': latest['timestamp'],
                        'ohlc': {
                            'open': latest['open'],
                            'high': latest['high'], 
                            'low': latest['low'],
                            'close': latest['close']
                        }
                    }
                    
                    # Update portfolio positions if they exist
                    if symbol in self.portfolio_state.positions:
                        self.portfolio_state.update_position_price(symbol, latest['close'])
                
            except Exception as e:
                self.logger.error(f"Failed to fetch data for {symbol}: {e}")
        
        return current_data
    
    async def _update_indicators(self, symbols: List[str], current_data: Dict[str, Dict[str, Any]]) -> None:
        """Update technical indicator cache"""
        
        for symbol in symbols:
            # Check if cache needs update
            cache_key = f"{symbol}_{self.config.timeframe}"
            last_update = self.cache_last_updated.get(cache_key)
            
            if (last_update is None or 
                (datetime.now() - last_update) > timedelta(minutes=15)):  # Update every 15 minutes
                
                try:
                    # Fetch historical data for indicators
                    data = await self.data_connector.get_market_data(
                        symbol, 
                        "6mo",  # 6 months for indicators
                        self.config.timeframe
                    )
                    
                    if data['data']:
                        df = pd.DataFrame(data['data'])
                        df['timestamp'] = pd.to_datetime(df['timestamp'])
                        df.set_index('timestamp', inplace=True)
                        df.sort_index(inplace=True)
                        
                        # Calculate indicators
                        indicators = self._calculate_technical_indicators(df)
                        self.indicator_cache[symbol] = indicators
                        self.cache_last_updated[cache_key] = datetime.now()
                        
                        self.logger.debug(f"Updated indicators for {symbol}")
                        
                except Exception as e:
                    self.logger.error(f"Failed to update indicators for {symbol}: {e}")
    
    def _calculate_technical_indicators(self, df: pd.DataFrame) -> Dict[str, pd.Series]:
        """Calculate technical indicators from OHLCV data"""
        indicators = {}
        
        try:
            # Moving Averages
            for period in [5, 10, 20, 50, 100, 200]:
                indicators[f'sma_{period}'] = df['close'].rolling(window=period).mean()
                indicators[f'ema_{period}'] = df['close'].ewm(span=period).mean()
            
            # RSI
            delta = df['close'].diff()
            gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
            loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
            rs = gain / loss
            indicators['rsi'] = 100 - (100 / (1 + rs))
            
            # MACD
            ema12 = df['close'].ewm(span=12).mean()
            ema26 = df['close'].ewm(span=26).mean()
            indicators['macd'] = ema12 - ema26
            indicators['macd_signal'] = indicators['macd'].ewm(span=9).mean()
            indicators['macd_histogram'] = indicators['macd'] - indicators['macd_signal']
            
            # Bollinger Bands
            sma20 = df['close'].rolling(window=20).mean()
            std20 = df['close'].rolling(window=20).std()
            indicators['bb_upper'] = sma20 + (std20 * 2)
            indicators['bb_lower'] = sma20 - (std20 * 2)
            indicators['bb_middle'] = sma20
            
            # Volume indicators
            indicators['volume_sma_10'] = df['volume'].rolling(window=10).mean()
            indicators['volume_sma_20'] = df['volume'].rolling(window=20).mean()
            
            # Volatility
            indicators['atr'] = self._calculate_atr(df)
            indicators['volatility_20'] = df['close'].pct_change().rolling(window=20).std()
            
            # Price-based
            indicators['returns'] = df['close'].pct_change()
            indicators['price'] = df['close']
            
        except Exception as e:
            self.logger.error(f"Error calculating indicators: {e}")
        
        return indicators
    
    def _calculate_atr(self, df: pd.DataFrame, period: int = 14) -> pd.Series:
        """Calculate Average True Range"""
        high_low = df['high'] - df['low']
        high_close = (df['high'] - df['close'].shift()).abs()
        low_close = (df['low'] - df['close'].shift()).abs()
        
        true_range = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
        return true_range.rolling(window=period).mean()
    
    async def _evaluate_strategy_tree(self, strategy: StrategyTree, current_data: Dict[str, Dict[str, Any]]) -> List[TradingSignal]:
        """Evaluate strategy tree against current market conditions"""
        signals = []
        
        async def evaluate_node(node: StrategyNode, parent_context: str = "") -> List[TradingSignal]:
            """Recursively evaluate strategy node"""
            node_signals = []
            
            if not node.enabled:
                return node_signals
            
            # Evaluate conditions
            conditions_met = await self._evaluate_conditions(node, current_data)
            
            if conditions_met:
                # Generate signals from actions
                for action in node.actions:
                    signal = await self._create_signal_from_action(
                        action, node, strategy, current_data, parent_context
                    )
                    if signal:
                        node_signals.append(signal)
                
                # Continue to child nodes
                context = f"{parent_context} -> {node.name}" if parent_context else node.name
                for child in node.children:
                    child_signals = await evaluate_node(child, context)
                    node_signals.extend(child_signals)
            
            return node_signals
        
        # Start evaluation from root
        all_signals = await evaluate_node(strategy.root_node)
        signals.extend(all_signals)
        
        return signals
    
    async def _evaluate_conditions(self, node: StrategyNode, current_data: Dict[str, Dict[str, Any]]) -> bool:
        """Evaluate all conditions for a node"""
        if not node.conditions:
            return True  # No conditions = always true
        
        condition_results = []
        
        for condition in node.conditions:
            result = await self._evaluate_single_condition(condition, current_data)
            condition_results.append(result)
        
        # Apply condition logic
        if node.condition_logic == "and":
            return all(condition_results)
        elif node.condition_logic == "or":
            return any(condition_results)
        else:
            return all(condition_results)  # Default to AND
    
    async def _evaluate_single_condition(self, condition: Condition, current_data: Dict[str, Dict[str, Any]]) -> bool:
        """Evaluate a single condition"""
        try:
            if condition.type == ConditionType.TECHNICAL_INDICATOR:
                return await self._evaluate_technical_condition(condition, current_data)
            
            elif condition.type == ConditionType.PRICE_COMPARISON:
                return await self._evaluate_price_condition(condition, current_data)
            
            elif condition.type == ConditionType.VOLUME_COMPARISON:
                return await self._evaluate_volume_condition(condition, current_data)
            
            elif condition.type == ConditionType.TIME_CONDITION:
                return self._evaluate_time_condition(condition)
            
            elif condition.type == ConditionType.SENTIMENT_CONDITION:
                return await self._evaluate_sentiment_condition(condition)
            
            elif condition.type == ConditionType.PORTFOLIO_CONDITION:
                return self._evaluate_portfolio_condition(condition)
            
            return False
            
        except Exception as e:
            self.logger.error(f"Error evaluating condition: {e}")
            return False
    
    async def _evaluate_technical_condition(self, condition: Condition, current_data: Dict[str, Dict[str, Any]]) -> bool:
        """Evaluate technical indicator condition"""
        
        # Get the primary symbol (first symbol in data)
        symbol = list(current_data.keys())[0] if current_data else None
        
        if not symbol or symbol not in self.indicator_cache:
            return False
        
        indicators = self.indicator_cache[symbol]
        
        if condition.indicator == IndicatorType.RSI:
            if 'rsi' not in indicators:
                return False
            
            current_rsi = indicators['rsi'].iloc[-1]
            if pd.isna(current_rsi):
                return False
            
            return self._compare_values(current_rsi, condition.operator.value, condition.value)
        
        elif condition.indicator in [IndicatorType.SMA, IndicatorType.EMA]:
            period = condition.parameters.get('period', 20)
            indicator_name = f"{condition.indicator.value}_{period}"
            
            if indicator_name not in indicators:
                return False
            
            current_value = indicators[indicator_name].iloc[-1]
            if pd.isna(current_value):
                return False
            
            # Handle MA crossover comparison
            if condition.parameters.get('comparison_type') == 'ma_crossover':
                short_period = condition.parameters.get('short_period', 10)
                long_period = condition.parameters.get('long_period', 50)
                
                short_ma_name = f"sma_{short_period}"
                long_ma_name = f"sma_{long_period}"
                
                if (short_ma_name not in indicators or long_ma_name not in indicators):
                    return False
                
                short_ma = indicators[short_ma_name].iloc[-1]
                long_ma = indicators[long_ma_name].iloc[-1]
                
                if pd.isna(short_ma) or pd.isna(long_ma):
                    return False
                
                return self._compare_values(short_ma, condition.operator.value, long_ma)
            
            # Regular comparison
            return self._compare_values(current_value, condition.operator.value, condition.value)
        
        elif condition.indicator == IndicatorType.MACD:
            if 'macd' not in indicators:
                return False
            
            current_macd = indicators['macd'].iloc[-1]
            if pd.isna(current_macd):
                return False
            
            # Can compare MACD to signal line or zero
            if condition.parameters.get('compare_to') == 'signal':
                signal_value = indicators['macd_signal'].iloc[-1]
                return self._compare_values(current_macd, condition.operator.value, signal_value)
            else:
                return self._compare_values(current_macd, condition.operator.value, condition.value)
        
        return False
    
    async def _evaluate_price_condition(self, condition: Condition, current_data: Dict[str, Dict[str, Any]]) -> bool:
        """Evaluate price comparison condition"""
        symbol = list(current_data.keys())[0] if current_data else None
        
        if not symbol or symbol not in current_data:
            return False
        
        current_price = current_data[symbol]['price']
        return self._compare_values(current_price, condition.operator.value, condition.value)
    
    async def _evaluate_volume_condition(self, condition: Condition, current_data: Dict[str, Dict[str, Any]]) -> bool:
        """Evaluate volume comparison condition"""
        symbol = list(current_data.keys())[0] if current_data else None
        
        if not symbol or symbol not in current_data:
            return False
        
        current_volume = current_data[symbol]['volume']
        
        # Compare to average volume if specified
        if 'volume_sma_20' in self.indicator_cache.get(symbol, {}):
            avg_volume = self.indicator_cache[symbol]['volume_sma_20'].iloc[-1]
            if not pd.isna(avg_volume):
                volume_multiple = current_volume / avg_volume
                return self._compare_values(volume_multiple, condition.operator.value, condition.value)
        
        return self._compare_values(current_volume, condition.operator.value, condition.value)
    
    def _evaluate_time_condition(self, condition: Condition) -> bool:
        """Evaluate time-based condition"""
        now = datetime.now()
        
        # Simple time conditions
        if condition.parameters.get('time_type') == 'hour':
            current_hour = now.hour
            return self._compare_values(current_hour, condition.operator.value, condition.value)
        
        elif condition.parameters.get('time_type') == 'day_of_week':
            current_dow = now.weekday()  # 0=Monday, 6=Sunday
            return self._compare_values(current_dow, condition.operator.value, condition.value)
        
        return True
    
    async def _evaluate_sentiment_condition(self, condition: Condition) -> bool:
        """Evaluate sentiment condition"""
        try:
            # Get sentiment data
            sentiment_data = await self.data_connector.get_sentiment(condition.parameters.get('indicator', 'vix'))
            
            if sentiment_data:
                sentiment_value = sentiment_data['value']
                return self._compare_values(sentiment_value, condition.operator.value, condition.value)
            
        except Exception as e:
            self.logger.error(f"Error evaluating sentiment condition: {e}")
        
        return False
    
    def _evaluate_portfolio_condition(self, condition: Condition) -> bool:
        """Evaluate portfolio-level condition"""
        if condition.parameters.get('condition_type') == 'total_exposure':
            return self._compare_values(self.portfolio_state.total_exposure_pct, 
                                      condition.operator.value, condition.value)
        
        elif condition.parameters.get('condition_type') == 'cash_level':
            cash_pct = (self.portfolio_state.cash / self.portfolio_state.total_value) * 100
            return self._compare_values(cash_pct, condition.operator.value, condition.value)
        
        return True
    
    def _compare_values(self, left: float, operator: str, right: float) -> bool:
        """Compare two values using the given operator"""
        if operator == '>':
            return left > right
        elif operator == '<':
            return left < right
        elif operator == '>=':
            return left >= right
        elif operator == '<=':
            return left <= right
        elif operator == '==':
            return abs(left - right) < 1e-6
        elif operator == '!=':
            return abs(left - right) >= 1e-6
        else:
            return False
    
    async def _create_signal_from_action(
        self, 
        action: Action,
        node: StrategyNode, 
        strategy: StrategyTree,
        current_data: Dict[str, Dict[str, Any]],
        context: str
    ) -> Optional[TradingSignal]:
        """Create trading signal from strategy action"""
        
        symbol = action.symbol
        if symbol not in current_data:
            self.logger.warning(f"No current data for {symbol}")
            return None
        
        # Check signal cooldown
        if self._is_signal_on_cooldown(symbol):
            return None
        
        # Check daily signal limit
        if self.daily_signal_count >= self.config.max_signals_per_day:
            return None
        
        current_price = current_data[symbol]['price']
        
        # Map action type to signal type
        signal_type_mapping = {
            ActionType.BUY: SignalType.BUY,
            ActionType.SELL: SignalType.SELL,
            ActionType.HOLD: SignalType.HOLD,
            ActionType.REBALANCE: SignalType.REBALANCE,
            ActionType.STOP_LOSS: SignalType.STOP_LOSS,
            ActionType.TAKE_PROFIT: SignalType.TAKE_PROFIT
        }
        
        signal_type = signal_type_mapping.get(action.type, SignalType.HOLD)
        
        # Calculate position size
        amount = self._calculate_signal_amount(action, current_price)
        
        # Calculate stop loss and take profit prices
        stop_loss_price = None
        take_profit_price = None
        
        if node.stop_loss_pct and signal_type == SignalType.BUY:
            stop_loss_price = current_price * (1 - node.stop_loss_pct / 100)
        
        if node.take_profit_pct and signal_type == SignalType.BUY:
            take_profit_price = current_price * (1 + node.take_profit_pct / 100)
        
        # Generate reasoning
        reasoning = self._generate_signal_reasoning(action, node, context, current_data)
        
        # Calculate confidence based on indicator strength
        confidence = self._calculate_signal_confidence(node, symbol)
        
        signal = TradingSignal(
            signal_type=signal_type,
            symbol=symbol,
            amount=amount,
            sizing_method=action.sizing_method,
            price=current_price,
            confidence=confidence,
            reasoning=reasoning,
            strategy_id=strategy.id,
            node_id=node.id,
            timestamp=datetime.now(),
            stop_loss_price=stop_loss_price,
            take_profit_price=take_profit_price,
            max_position_size=node.max_position_size
        )
        
        # Update tracking
        self.last_signal_time[symbol] = datetime.now()
        self.daily_signal_count += 1
        
        return signal
    
    def _calculate_signal_amount(self, action: Action, current_price: float) -> float:
        """Calculate signal amount based on action sizing method"""
        if action.sizing_method == PositionSizingMethod.PERCENTAGE:
            # Percentage of portfolio value
            return (self.portfolio_state.total_value * action.amount) / 100.0
        
        elif action.sizing_method == PositionSizingMethod.FIXED_AMOUNT:
            return action.amount
        
        elif action.sizing_method == PositionSizingMethod.RISK_BASED:
            # Risk-based sizing (simplified)
            risk_amount = self.portfolio_state.total_value * 0.02  # 2% risk
            return risk_amount
        
        elif action.sizing_method == PositionSizingMethod.VOLATILITY_ADJUSTED:
            # Volatility-adjusted sizing (simplified)
            base_amount = (self.portfolio_state.total_value * action.amount) / 100.0
            # Could adjust based on volatility here
            return base_amount
        
        else:
            return action.amount
    
    def _generate_signal_reasoning(
        self, 
        action: Action,
        node: StrategyNode,
        context: str,
        current_data: Dict[str, Dict[str, Any]]
    ) -> str:
        """Generate human-readable reasoning for the signal"""
        
        symbol = action.symbol
        price = current_data[symbol]['price']
        
        # Start with basic action description
        action_desc = f"{action.type.value.upper()} {symbol} at ${price:.2f}"
        
        # Add sizing information
        if action.sizing_method == PositionSizingMethod.PERCENTAGE:
            action_desc += f" ({action.amount}% of portfolio)"
        else:
            action_desc += f" (${action.amount:,.2f})"
        
        # Add node context
        reasoning_parts = [
            action_desc,
            f"Triggered by: {node.name}",
        ]
        
        # Add condition explanations
        if node.conditions:
            condition_explanations = []
            for condition in node.conditions:
                explanation = self._explain_condition(condition, symbol)
                if explanation:
                    condition_explanations.append(explanation)
            
            if condition_explanations:
                reasoning_parts.append(f"Conditions: {' AND '.join(condition_explanations)}")
        
        # Add risk management info
        risk_info = []
        if node.stop_loss_pct:
            risk_info.append(f"Stop Loss: {node.stop_loss_pct}%")
        if node.take_profit_pct:
            risk_info.append(f"Take Profit: {node.take_profit_pct}%")
        
        if risk_info:
            reasoning_parts.append(f"Risk Management: {', '.join(risk_info)}")
        
        # Add strategy path
        if context:
            reasoning_parts.append(f"Strategy Path: {context}")
        
        return " | ".join(reasoning_parts)
    
    def _explain_condition(self, condition: Condition, symbol: str) -> str:
        """Generate explanation for a condition"""
        try:
            if condition.type == ConditionType.TECHNICAL_INDICATOR:
                if condition.indicator == IndicatorType.RSI:
                    period = condition.parameters.get('period', 14)
                    current_rsi = self.indicator_cache.get(symbol, {}).get('rsi', pd.Series()).iloc[-1]
                    if not pd.isna(current_rsi):
                        return f"RSI({period})={current_rsi:.1f} {condition.operator.value} {condition.value}"
                
                elif condition.indicator in [IndicatorType.SMA, IndicatorType.EMA]:
                    period = condition.parameters.get('period', 20)
                    indicator_name = f"{condition.indicator.value}_{period}"
                    current_value = self.indicator_cache.get(symbol, {}).get(indicator_name, pd.Series()).iloc[-1]
                    if not pd.isna(current_value):
                        return f"{condition.indicator.value.upper()}({period})=${current_value:.2f} {condition.operator.value} ${condition.value:.2f}"
            
            return condition.description or f"{condition.type.value} condition"
            
        except Exception:
            return condition.description or "Technical condition"
    
    def _calculate_signal_confidence(self, node: StrategyNode, symbol: str) -> float:
        """Calculate signal confidence based on indicator strength and convergence"""
        
        confidence = 0.7  # Base confidence
        
        try:
            # Increase confidence if multiple conditions are met
            if len(node.conditions) > 1:
                confidence += 0.1
            
            # Increase confidence based on RSI extremes
            if symbol in self.indicator_cache and 'rsi' in self.indicator_cache[symbol]:
                current_rsi = self.indicator_cache[symbol]['rsi'].iloc[-1]
                if not pd.isna(current_rsi):
                    if current_rsi < 30 or current_rsi > 70:  # RSI extremes
                        confidence += 0.1
            
            # Increase confidence for high volume
            # (Would need volume comparison logic here)
            
            # Decrease confidence if market is choppy (high volatility)
            if symbol in self.indicator_cache and 'volatility_20' in self.indicator_cache[symbol]:
                volatility = self.indicator_cache[symbol]['volatility_20'].iloc[-1]
                if not pd.isna(volatility) and volatility > 0.03:  # > 3% daily volatility
                    confidence -= 0.1
                    
        except Exception as e:
            self.logger.error(f"Error calculating confidence: {e}")
        
        return max(0.1, min(1.0, confidence))  # Clamp between 0.1 and 1.0
    
    def _is_signal_on_cooldown(self, symbol: str) -> bool:
        """Check if symbol is on signal cooldown"""
        if symbol not in self.last_signal_time:
            return False
        
        time_since_last = datetime.now() - self.last_signal_time[symbol]
        cooldown_period = timedelta(minutes=self.config.signal_cooldown_minutes)
        
        return time_since_last < cooldown_period
    
    def _is_market_hours(self) -> bool:
        """Check if current time is during market hours (simplified)"""
        now = datetime.now()
        
        # Simple US market hours check (9:30 AM - 4:00 PM ET, Monday-Friday)
        if now.weekday() >= 5:  # Weekend
            return False
        
        # Very simplified - doesn't account for timezones or holidays
        hour = now.hour
        minute = now.minute
        
        market_open = (hour > 9) or (hour == 9 and minute >= 30)
        market_close = hour < 16
        
        return market_open and market_close
    
    def _apply_safety_filters(self, signals: List[TradingSignal]) -> List[TradingSignal]:
        """Apply safety filters to signals"""
        filtered_signals = []
        
        for signal in signals:
            # Circuit breaker check
            if self.circuit_breaker and not self.circuit_breaker.is_signal_safe(signal):
                self.logger.warning(f"Circuit breaker blocked signal: {signal.symbol}")
                continue
            
            # Position size check
            max_position_value = self.portfolio_state.total_value * (self.config.max_position_size_pct / 100)
            if signal.amount > max_position_value:
                self.logger.warning(f"Signal amount ${signal.amount:.2f} exceeds max position size")
                signal.amount = max_position_value
            
            # Portfolio exposure check
            total_new_exposure = sum(s.amount for s in filtered_signals) + signal.amount
            max_exposure = self.portfolio_state.total_value * (self.config.max_portfolio_exposure_pct / 100)
            
            if total_new_exposure > max_exposure:
                self.logger.warning(f"Signal would exceed max portfolio exposure")
                continue
            
            filtered_signals.append(signal)
        
        return filtered_signals
    
    def get_signal_history(self, hours: int = 24) -> List[TradingSignal]:
        """Get recent signal history"""
        cutoff_time = datetime.now() - timedelta(hours=hours)
        return [s for s in self.signal_history if s.timestamp >= cutoff_time]
    
    def get_portfolio_state(self) -> PortfolioState:
        """Get current portfolio state"""
        return self.portfolio_state
    
    async def update_portfolio_positions(self, positions: Dict[str, PortfolioPosition]) -> None:
        """Update portfolio positions for better signal sizing"""
        self.portfolio_state.positions = positions
        
        # Recalculate total values
        position_value = sum(pos.market_value for pos in positions.values())
        self.portfolio_state.total_value = self.portfolio_state.cash + position_value
        
        # Update exposure
        self.portfolio_state.total_exposure_pct = (position_value / self.portfolio_state.total_value) * 100

# Convenience function
async def execute_strategy_signals(
    strategy: StrategyTree,
    config: Optional[ExecutionConfig] = None,
    portfolio_value: Optional[float] = None
) -> List[TradingSignal]:
    """Convenience function to execute strategy and get signals"""
    if config is None:
        config = ExecutionConfig()
    
    runner = ExecutionRunner(config)
    return await runner.execute_strategy(strategy, portfolio_value)